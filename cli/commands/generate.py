import typer
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt
from rich.table import Table
from rich.text import Text

from core.adapters.openai_adapter import OpenAIAdapter
from core.models import ChatSession
from core.storage import AuthorStorage, get_author_profile

console = Console()
generate_app = typer.Typer()


@generate_app.command("text")
def generate_text(
    author_id: str = typer.Argument(..., help="Author ID to generate text for"),
    prompt: str = typer.Option(
        None, "--prompt", "-p", help="Prompt for text generation"
    ),
    max_completion_tokens: int = typer.Option(
        500, "--max-completion-tokens", help="Maximum tokens to generate"
    ),
    save: bool = typer.Option(
        True, "--save/--no-save", help="Save generated content to file"
    ),
):
    """âœï¸  Generate text using a fine-tuned model."""

    profile = get_author_profile(author_id)
    if not profile:
        console.print(f"[red]Author '{author_id}' not found.[/red]")
        raise typer.Exit(1)

    storage = AuthorStorage(author_id)
    metadata = storage.load_model_metadata()

    # Find latest successful model
    job = metadata.get_latest_successful_job()
    if not job or not job.fine_tuned_model:
        console.print(f"[red]No fine-tuned model found for '{author_id}'.[/red]")
        console.print(f"Use 'simtune train start {author_id}' to create one.")
        raise typer.Exit(1)

    model_id = job.fine_tuned_model

    # Get prompt if not provided
    if not prompt:
        prompt = Prompt.ask("Enter your prompt")

    console.print(f"\n[yellow]Prompt:[/yellow] {prompt}")
    console.print(f"[dim]Using model: {model_id}[/dim]")

    try:
        adapter = OpenAIAdapter()
        response = adapter.generate_text(model_id, prompt, max_completion_tokens)

        console.print(
            Panel(
                response, title=f"âœï¸  Generated by {profile.name}", border_style="green"
            )
        )

        # Save generated content if requested
        if save:
            try:
                content_path = storage.save_generated_content(
                    prompt=prompt,
                    response=response,
                    author_name=profile.name,
                    model_id=model_id,
                )
                console.print(f"[dim]ðŸ’¾ Saved to: {content_path.name}[/dim]")
            except Exception as save_error:
                console.print(
                    f"[yellow]âš ï¸  Could not save content: {save_error}[/yellow]"
                )

    except ValueError as e:
        # Configuration error
        console.print(f"[red]Configuration error: {e}[/red]")
        raise typer.Exit(1)
    except Exception as e:
        console.print(f"[red]Error generating text: {str(e)}[/red]")
        raise typer.Exit(1)


@generate_app.command("interactive")
def interactive_generation(
    author_id: str = typer.Argument(..., help="Author ID for interactive generation"),
    save: bool = typer.Option(
        True, "--save/--no-save", help="Save generated content to files"
    ),
):
    """ðŸŽ¯ Interactive text generation session."""

    profile = get_author_profile(author_id)
    if not profile:
        console.print(f"[red]Author '{author_id}' not found.[/red]")
        raise typer.Exit(1)

    storage = AuthorStorage(author_id)
    metadata = storage.load_model_metadata()

    # Find latest successful model
    job = metadata.get_latest_successful_job()
    if not job or not job.fine_tuned_model:
        console.print(f"[red]No fine-tuned model found for '{author_id}'.[/red]")
        console.print(f"Use 'simtune train start {author_id}' to create one.")
        raise typer.Exit(1)

    model_id = job.fine_tuned_model

    save_status = "enabled" if save else "disabled"
    console.print(
        Panel(
            f"[bold blue]Interactive Generation Session[/bold blue]\n\n"
            f"Author: {profile.name}\n"
            f"Model: {model_id}\n"
            f"Content saving: {save_status}\n\n"
            f"Type 'quit' or 'exit' to end the session.",
            title="ðŸŽ¯ Generation Mode",
        )
    )

    try:
        adapter = OpenAIAdapter()

        while True:
            prompt = Prompt.ask("\n[cyan]Enter your prompt[/cyan]")

            if prompt.lower() in ["quit", "exit", "q"]:
                console.print("[green]Session ended.[/green]")
                break

            if not prompt.strip():
                console.print("[yellow]Please enter a prompt.[/yellow]")
                continue

            try:
                response = adapter.generate_text(
                    model_id, prompt, max_completion_tokens=500
                )
                console.print(
                    Panel(
                        response,
                        title=f"âœï¸  {profile.name}",
                        border_style="green",
                    )
                )

                # Save generated content if requested
                if save:
                    try:
                        content_path = storage.save_generated_content(
                            prompt=prompt,
                            response=response,
                            author_name=profile.name,
                            model_id=model_id,
                        )
                        console.print(f"[dim]ðŸ’¾ Saved to: {content_path.name}[/dim]")
                    except Exception as save_error:
                        console.print(
                            f"[yellow]âš ï¸  Could not save content: {save_error}[/yellow]"
                        )

            except Exception as e:
                console.print(f"[red]Error generating text: {str(e)}[/red]")

    except ValueError as e:
        # Configuration error
        console.print(f"[red]Configuration error: {e}[/red]")
        raise typer.Exit(1)
    except KeyboardInterrupt:
        console.print("\n[green]Session ended.[/green]")
    except Exception as e:
        console.print(f"[red]Error in interactive session: {str(e)}[/red]")
        raise typer.Exit(1)


@generate_app.command("chat")
def chat_session(
    author_id: str = typer.Argument(..., help="Author ID for chat session"),
    session_id: str = typer.Option(
        None, "--session", "-s", help="Resume existing session or create new one"
    ),
    save: bool = typer.Option(
        True, "--save/--no-save", help="Save chat session to file"
    ),
):
    """ðŸ’¬ Start a ChatGPT-style conversation with your fine-tuned model."""

    profile = get_author_profile(author_id)
    if not profile:
        console.print(f"[red]Author '{author_id}' not found.[/red]")
        raise typer.Exit(1)

    storage = AuthorStorage(author_id)
    metadata = storage.load_model_metadata()

    # Find latest successful model
    job = metadata.get_latest_successful_job()
    if not job or not job.fine_tuned_model:
        console.print(f"[red]No fine-tuned model found for '{author_id}'.[/red]")
        console.print(f"Use 'simtune train start {author_id}' to create one.")
        raise typer.Exit(1)

    model_id = job.fine_tuned_model

    # Load or create chat session
    if session_id:
        session = storage.load_chat_session(session_id)
        if not session:
            console.print(f"[red]Chat session '{session_id}' not found.[/red]")
            raise typer.Exit(1)
        console.print(f"[green]Resumed chat session: {session_id}[/green]")
    else:
        session = ChatSession(author_id=author_id)
        if save:
            storage.save_chat_session(session)
        console.print(f"[green]Started new chat session: {session.session_id}[/green]")

    # Display chat header
    _display_chat_header(profile.name, model_id, session, save)

    # Show conversation history if resuming
    if session.messages:
        _display_conversation_history(session, profile.name)

    try:
        adapter = OpenAIAdapter()

        while True:
            user_input = Prompt.ask("\n[cyan]ðŸ’¬[/cyan]")

            # Handle chat commands
            if user_input.startswith("/"):
                if _handle_chat_command(user_input, session, storage, profile.name):
                    continue
                else:
                    break  # Exit command

            if not user_input.strip():
                console.print(
                    "[yellow]Please enter a message or use /help for commands.[/yellow]"
                )
                continue

            # Add user message to session
            session.add_message("user", user_input)

            # Display user message
            _display_user_message(user_input)

            try:
                # Generate response using conversation history
                messages = session.get_openai_messages()
                response = adapter.generate_chat_response(
                    model_id, messages, max_completion_tokens=500
                )

                # Add assistant response to session
                session.add_message("assistant", response)

                # Display assistant response
                _display_assistant_message(response, profile.name)

                # Save session if enabled
                if save:
                    storage.save_chat_session(session)

            except Exception as e:
                console.print(f"[red]Error generating response: {str(e)}[/red]")
                # Remove the user message since we couldn't respond
                if session.messages and session.messages[-1].role == "user":
                    session.messages.pop()

    except KeyboardInterrupt:
        console.print("\n[green]Chat session ended.[/green]")
        if save:
            storage.save_chat_session(session)
    except Exception as e:
        console.print(f"[red]Error in chat session: {str(e)}[/red]")
        raise typer.Exit(1)


def _display_chat_header(
    author_name: str, model_id: str, session: ChatSession, save_enabled: bool
) -> None:
    """Display the chat session header."""
    save_status = "enabled" if save_enabled else "disabled"
    console.print(
        Panel(
            f"[bold blue]ðŸ’¬ Chat Session[/bold blue]\n\n"
            f"Author: {author_name}\n"
            f"Model: {model_id}\n"
            f"Session: {session.session_id}\n"
            f"Messages: {session.message_count}\n"
            f"Auto-save: {save_status}\n\n"
            f"Type your message to chat, or use /help for commands.",
            title="ðŸ¤– Chat Mode",
            border_style="blue",
        )
    )


def _display_conversation_history(session: ChatSession, author_name: str) -> None:
    """Display the conversation history."""
    console.print("\n[dim]--- Conversation History ---[/dim]")
    for msg in session.messages:
        if msg.role == "user":
            _display_user_message(msg.content, show_timestamp=False)
        else:
            _display_assistant_message(msg.content, author_name, show_timestamp=False)
    console.print("[dim]--- End History ---[/dim]")


def _display_user_message(content: str, show_timestamp: bool = True) -> None:
    """Display a user message."""
    timestamp = f" [dim]({_format_timestamp()})[/dim]" if show_timestamp else ""
    console.print(f"\n[bold cyan]ðŸ§‘ You:{timestamp}[/bold cyan]")
    console.print(f"[white]{content}[/white]")


def _display_assistant_message(
    content: str, author_name: str, show_timestamp: bool = True
) -> None:
    """Display an assistant message."""
    timestamp = f" [dim]({_format_timestamp()})[/dim]" if show_timestamp else ""
    console.print(f"\n[bold green]ðŸ¤– {author_name}:{timestamp}[/bold green]")
    console.print(Panel(content, border_style="green", padding=(0, 1)))


def _format_timestamp() -> str:
    """Format current timestamp for display."""
    from datetime import datetime

    return datetime.now().strftime("%H:%M:%S")


def _handle_chat_command(
    command: str, session: ChatSession, storage: AuthorStorage, author_name: str
) -> bool:
    """Handle chat commands. Returns True to continue chat, False to exit."""
    cmd = command.lower().strip()

    if cmd in ["/quit", "/exit", "/q"]:
        console.print("[green]Chat session ended.[/green]")
        return False

    elif cmd == "/clear":
        session.clear_messages()
        storage.save_chat_session(session)
        console.print("[green]Conversation cleared.[/green]")
        return True

    elif cmd == "/history":
        if session.messages:
            _display_conversation_history(session, author_name)
        else:
            console.print("[yellow]No conversation history yet.[/yellow]")
        return True

    elif cmd == "/save":
        storage.save_chat_session(session)
        console.print(f"[green]Session saved: {session.session_id}[/green]")
        return True

    elif cmd in ["/export", "/export-md"]:
        export_path = storage.export_chat_session_as_markdown(session, author_name)
        console.print(f"[green]Chat exported to: {export_path.name}[/green]")
        return True

    elif cmd == "/info":
        _display_session_info(session)
        return True

    elif cmd == "/sessions":
        _display_available_sessions(storage)
        return True

    elif cmd in ["/help", "/?"]:
        _display_chat_help()
        return True

    else:
        console.print(f"[yellow]Unknown command: {command}[/yellow]")
        console.print("Use /help to see available commands.")
        return True


def _display_session_info(session: ChatSession) -> None:
    """Display information about the current session."""
    table = Table(title="Session Information")
    table.add_column("Property", style="cyan")
    table.add_column("Value", style="white")

    table.add_row("Session ID", session.session_id)
    table.add_row("Author ID", session.author_id)
    table.add_row("Created", str(session.created_at))
    table.add_row("Updated", str(session.updated_at))
    table.add_row("Messages", str(session.message_count))

    if session.last_message_time:
        table.add_row("Last Message", str(session.last_message_time))

    console.print(table)


def _display_available_sessions(storage: AuthorStorage) -> None:
    """Display available chat sessions."""
    sessions = storage.list_chat_sessions()

    if not sessions:
        console.print("[yellow]No saved chat sessions found.[/yellow]")
        return

    table = Table(title="Available Chat Sessions")
    table.add_column("Session ID", style="cyan")
    table.add_column("Created", style="white")
    table.add_column("Messages", style="yellow")

    for session_id in sessions[:10]:  # Show latest 10
        session = storage.load_chat_session(session_id)
        if session:
            table.add_row(
                session_id[:16] + "..." if len(session_id) > 19 else session_id,
                session.created_at.strftime("%Y-%m-%d %H:%M"),
                str(session.message_count),
            )

    console.print(table)
    if len(sessions) > 10:
        console.print(f"[dim]... and {len(sessions) - 10} more sessions[/dim]")


def _display_chat_help() -> None:
    """Display chat commands help."""
    help_text = """[bold cyan]Chat Commands:[/bold cyan]

[yellow]/help[/yellow]     - Show this help message
[yellow]/clear[/yellow]    - Clear conversation history  
[yellow]/history[/yellow]  - Show conversation history
[yellow]/save[/yellow]     - Save current session
[yellow]/export[/yellow]   - Export chat as markdown
[yellow]/info[/yellow]     - Show session information
[yellow]/sessions[/yellow] - List available sessions
[yellow]/quit[/yellow]     - End chat session

[dim]Just type your message to continue chatting![/dim]
"""
    console.print(Panel(help_text, title="ðŸ’¬ Chat Help", border_style="blue"))
